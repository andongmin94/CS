### [13강. 명령어 병렬 처리 기법](https://www.youtube.com/watch?v=Btsa_U-f26k)

- 어떻게 CPU가 시간낭비없이 명령어를 처리할 수 있을까?
- 명령어 파이프라인
  - 명령어가 처리되는 과정을 비슷한 시간 간격으로 나누면?
    - 1. 명령어 인출(Instruction Fetch)
      2. 명령어 해석(Instruction Decode)
      3. 명령어 실행(Execute Instruction)
      4. 결과 저장(Write Back)
  - 같은 단계가 겹치지 않는다면 CPU는 '각 단계를 동시에 실행할 수 있다'
![image](https://github.com/user-attachments/assets/de27afc1-0b6e-43b1-8feb-de47bfa00936)
  - 파이프라인 위험 : 명령어 파이프라인이 성능 향상에 실패하는 경우
![image](https://github.com/user-attachments/assets/6ab53795-4bc9-4a11-a69f-7dd1e3f2f253)
    - 데이터 위험 : 명령어 간의 의존성에 의해 야기(특정 명령어 실행이 선행되어야 하는 경우)
    - 제어 위험 : 프로그램 카운터의 갑작스러운 변화(특정 메모리 주소가 갑자기 변경되는 경우, 이를테면 jump)
    - 구조 위험 : 서로 다른 명령어가 같은 CPU부품(ALU, 레지스터)를 쓰려고 할 때
- 슈퍼스칼라
  - CPU 내부에 여러개의 명령어 파이프라인을 포함한 구조
  - 이론적으로는 파이프라인 개수에 비례하여 처리 속도가 증가함.
  - 허나 파이프라인 위험도 증가로 인해 실제로는 비례하여 처리 속도가 증가하진 않음.
- 비순차적 명령어 처리 : 파이프라인의 중단을 방지하기 위해 명령어를 순차적으로 처리하지 않는 명령어 병렬처리 기법
